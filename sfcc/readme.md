# femto-C v0.5.0 문법 표준안
femto-C v0.5.0 Grammar Standard

# 1. 문법 명세
1. Grammar Specification

이 항목은 femto-C의 문법과 동작을 정의합니다. 기본적으로 C 스타일의 문법을 사용하며, 이 문서에 명시되지 않은 사항은 정의되지 않은 행동이거나 표준 컴파일러의 구현 정의를 따릅니다.

## 1.1. 프로그램 구조

복잡한 헤더 파일과 전역 변수명 겹침으로부터 벗어나세요. femto-C는 모듈 기반으로 이름과 접근을 제어합니다.

### 1.1.1. 모듈

femto-C는 파일 경로 기반 모듈 시스템을 사용합니다. 소스 파일 하나가 모듈 하나입니다. 모듈은 다른 모듈을 불러와 사용할 수도 있지만, 순환 참조는 허용되지 않습니다. 모듈 파일 경로로 절대경로와 상대경로 모두 사용 가능합니다. 상대경로를 쓰는 경우 호출자 소스의 위치를 기준으로 상대 경로를 사용합니다.

```cpp
include "path_to_module" name
name.Object v;
```

`include` 키워드로 다른 모듈을 불러오고 접근 이름을 지정합니다. 점 연산자로 다른 모듈 항목에 접근합니다. 전역변수와 함수, 구조체와 열거형 타입, 타입 별칭 선언문이 다른 모듈에서 사용될 수 있습니다.

### 1.1.2. 표현식, 문장, 선언문, 주석

프로그램은 모듈로 구성되고, 모듈은 선언문으로 구성됩니다. 표현식, 문장, 선언문, 주석은 C와 동일하게 사용됩니다.

```cpp
1 + 2
myVar.Method(a)
str[:]
```

표현식은 값을 가지며 어떠한 연산의 결과가 됩니다. 할당문의 좌변에 오는 표현식은 상수가 아니며 (non-const), 메모리 주소를 가진 (l-value) 표현식이여야 합니다.

```cpp
print("Hello");
myVar.count++;
1 + a;
```

문장은 프로그램이 동작하도록 명령을 내립니다. 문장의 종류로는 어떤 이름이나 타입을 선언하는 선언문, 값을 좌변에 대입하는 할당문, 값을 계산하거나 함수를 호출하는 표현식문이 있습니다.

```cpp
a = b;
a += b; // a = a + b;
a -= b; // a = a - b;
a *= b; // a = a * b;
a /= b; // a = a / b;
a %= b; // a = a % b;
arr[i++] += 1; // auto v = &arr[i++]; *v = *v + 1;
```

단순 할당자는 우변의 값을 좌변에 할당합니다. 복합 할당자는 좌변과 우변을 연산한 값(이때 좌변은 한 번만 평가됩니다)을 할당합니다. 할당문은 다음 할당자를 지원하며 `=, +=, -=, *=, /=, %=`, **이는 연산자로 취급하지 않습니다.** 즉 표현식 안에 할당문이 올 수 없습니다. 이는 고질적인 오타 문제(if (i = 0) ... 등)를 예방합니다.

```cpp
int i = 0;
void* p = null;
struct Point {int x; int y;}
```

선언문은 이름이나 타입을 선언합니다. 선언문으로 `모듈 접근자, 전역변수, 지역변수, 함수, 메소드, 타입 별칭`의 이름과 `구조체, 열거형, 템플릿` 타입을 선언할 수 있습니다.

```cpp
auto p = getPoint(4, 27);
Point getPoint(int x, int y) {
  Point ret = {x, y};
  return ret;
}
struct Point {int x; int y;}
```

변수를 제외하고 선언문은 호이스팅이 되어 사용부가 선언부보다 앞에 있어도 됩니다. 대신 **모든 선언은 동시에 정의가 있어야 합니다.**

```cpp
// single line comment
/*
  multi
  line
  comment
*/
```

주석은 C와 동일하게 한 줄 주석과 여러 줄 주석을 지원합니다.

### 1.1.3. 이름 명명 조건

식별자 이름으로 영문, 언더바, 유니코드 문자를 사용할 수 있습니다. 식별자명은 숫자로 시작해서는 안 됩니다. 유니코드 문자는 일부 컴파일러에서는 호환성 문제를 일으킬 수도 있습니다.

```cpp
basicVar
PubliVar
_privateVar
_012
한글_이름
```

다음 키워드와 기본 타입명은 식별자명으로 사용할 수 없습니다.

```cpp
include, template, struct, enum, defer, template,
va_arg, const, volatile, extern, export,
if, else, while, for, switch, case, default,
break, continue, fall, return,
cast, sizeof, len, make, move,
true, false, null, auto,
int, i8, i16, i32, i64,
uint, u8, u16, u32, u64,
f32, f64, bool, void,
raw_c, raw_ir
```

### 1.1.4. 스코프와 이름공간

중괄호로 스코프를 나타냅니다. 스코프는 이름이 유효한 범위를 의미합니다. 변수명과 타입 별칭은 로컬 스코프에서도 선언할 수 있습니다. 이외의 타입과 이름은 전역 공간에서만 선언할 수 있습니다. 이름은 선언하기 전에는 사용할 수 없습니다. 또한 전역 이름은 어디에서나 쓸 수 있지만, 로컬 이름은 스코프 안에서만 유효합니다.

```cpp
int PublicGlobal = 0;
int basicGlobal = 1;
{
  int local0 = 2;
  {
    int local1 = 3;
  }
}
```

모듈 접근자, 전역변수, 함수, 구조체명 등은 모두 전역 이름공간을 쓰므로 서로 겹칠 수 없습니다. 지역변수는 전역 이름공간이나 상위 스코프에서 선언된 이름을 쓸 수 있지만, 이 경우 해당 이름을 가리게 됩니다. 즉 중복 선언된 이름은 해당 이름이 유효한 스코프에서는 사전에 선언된 이름에 접근할 수 없습니다.

### 1.1.5. 가시성 규칙

femto-C는 간단한 대문자 가시성 규칙을 따릅니다. 이 규칙은 같은 femto-C 코드 사이에서의 가시성을 제어합니다.

```cpp
int PublicVar;
int basicVar;
struct Point {int A; int b; int _c;}
```

기본적으로 모듈 안에서 선언된 이름은 해당 모듈 안에서만 접근할 수 있습니다. 이름 첫 글자를 대문자[A-Z]로 한 경우에만 다른 모듈에서도 접근할 수 있는 공개 이름이 됩니다. 구조체 멤버와 메서드에 한해서, 언더바로 시작하는 이름은 내부명입니다. 이 이름은 해당 구조체의 메서드에서만 접근할 수 있습니다.

### 1.1.6. 전역 초기화와 프로그램 진입점

**전역변수는 상수 표현식으로만 초기화할 수 있습니다.** 이는 메인 함수 진입 전 따로 코드가 먼저 실행되는 것을 막습니다. 메인 함수는 정수를 반환하며, 실행 인자를 받을 수도 있습니다. 프로그램을 실행파일로 빌드하기 위해서는 메인 함수 진입점이 필요합니다.

```cpp
int main() { }
int main(u8[][]) { }
```


## 1.2. 타입 시스템

femto-C는 타입 중심 설계를 따릅니다. 이는 C의 표현식 중심 설계보다 정형적이지만 프로그래머가 변수의 타입을 추적하기 쉽습니다. 타입은 타입 뿌리에 타입 접미사를 붙여 의미를 표현합니다. 타입 선언에 공백을 사용할 수 있으며 괄호는 함수형 선언을 위해서만 쓰입니다.

### 1.2.1. 정수형 원시 타입

정수형 타입은 고정된 크기를 가지거나 아키텍쳐 결정 크기를 가집니다. 부호있는 정수형은 2의 보수 형태로 저장되며, 제로 비트패턴은 0임이 보장됩니다.

`int, i8, i16, i32, i64, uint, u8, u16, u32, u64`

### 1.2.2. 실수형 원시 타입

실수형 타입은 고정된 크기를 가집니다. IEEE 754 부동소수점 형태로 저장되며, 제로 비트패턴은 0임이 보장됩니다.

`f32, f64`

### 1.2.3. 기타 원시 타입

불리언 타입은 1 바이트 크기를 가집니다. 제로 비트패턴은 거짓, 나머지는 참으로 해석됩니다. 보이드 타입은 크기를 가지지 않으며 직접적으로 사용할 수 없습니다. 함수가 값을 반환하지 않음을 나타내거나, 임의 포인터(void*)를 표기하는데에 쓰입니다.

`bool, void`

### 1.2.4. 배열

타입 끝에 양의 정수 값이 들어있는 대괄호를 붙여 배열을 선언합니다. 배열은 연속한 데이터 덩어리입니다. **C와 달리 값 타입으로 취급되며 함수 호출이나 할당 시 값 자체가 복사됩니다.** C와 동일하게 다차원 배열을 선언할 수 있습니다. T[a][b]는 ((T가 b번 연속한 것)이 a번 연속한 것)을 의미합니다. define 변수도 배열 길이로 사용할 수 있습니다.

```cpp
int[4]
f32[16][32]

define n = 4;
i32[n] var;
```

### 1.2.5. 슬라이스

타입 끝에 빈 대괄호를 붙여 슬라이스를 선언합니다. 슬라이스는 데이터 포인터와 길이가 같이 들어있는 확장 포인터입니다. 일반 포인터의 2배 크기를 가집니다. 다차원으로 선언하거나 배열과 혼합하여 사용할 수 있습니다.

```cpp
int[]
f32[][]
u8[8][] // actual meaning ( u8[] )[8]
struct Slice {void* data; int length;} // inner structure
```

### 1.2.6. 포인터

타입 끝에 `*`를 붙여 포인터를 선언합니다. 포인터는 값이 메모리 주소이며 아키텍쳐 결정 크기를 가지는 정수형으로 생각할 수 있습니다. 임의의 자료형을 가리키기 위해서는 void*를 사용합니다.

```cpp
int*
f32**
void*
```

### 1.2.7. 함수 포인터

타입 끝에 괄호를 붙여 함수 포인터 타입을 선언합니다. 함수 포인터는 femto-C와 C의 타입 표기법 중 가장 차이가 큰 곳입니다. 함수 포인터 구조는 간단하게 직관적으로 생각하면 좋습니다.

```cpp
void()
int(int, int)
bool(i32, i32)(f64(f64, f64), i64)
```

위의 타입 세 가지는 다음 의미를 가집니다.
- 인자를 받지 않고 반환도 하지 않는 함수
- 인자로 정수형 2개를 받고 정수형을 반환하는 함수
- 인자로 ((인자로 64비트 실수형 2개를 받고 64비트 실수형을 반환하는 함수)와 64비트 정수형)를 받고 (인자로 32비트 정수형 2개를 받고 불리언을 반환하는 함수)를 반환하는 함수

### 1.2.8. 타입 별칭

`typedef` 키워드로 타입에 대한 다른 이름을 만들 수 있습니다. 타입 별칭은 변수와 같은 유효 범위(스코프 규칙, 대문자 규칙)를 가집니다.

```cpp
typedef str u8[]
typedef myFunc i32(i32, i32)

str[]
bool(myFunc, i32, i32)
```

### 1.2.9. 타입 변환

femto-C에는 암시적 형 변환이 없습니다. 명시적 캐스팅이 없다면 표현식의 타입은 바뀌지 않습니다. `cast` 키워드로 표현식의 타입을 변환할 수 있습니다. 변환 결과 타입은 유효한 타입이여야 합니다.

```cpp
cast<int>(expr)
cast<void*>(expr)
```

타입 변환은 다음과 같은 경우에만 허용됩니다.
- void를 제외한 원시 타입간 변환. 값 자체가 바뀌는 것이라 비트 패턴이 바뀔 수 있습니다.
- 정수형과 포인터형간 변환. 정수형이 음수라면 강제로 양수 비트 패턴으로 해석됩니다.
- 포인터형간의 변환. 포인터 대상에 상관 없이 무제한적으로 단순 변환됩니다.


## 1.3. 리터럴 표기

리터럴은 값 자체를 나타내며 사용되는 표현식에 따라 다른 타입을 가질 수도 있습니다.

### 1.3.1. 정수 리터럴

10진수, 2진수, 8진수, 16진수 정수형을 쓸 수 있습니다. 정수 리터럴이 컴파일 시간에 연산된다면 int64 공간에서 연산됩니다.

```cpp
0
42
-2147483649
0b1011
-0o755
0x8a91
0xFfff
```

### 1.3.2. 실수 리터럴

10진수 실수형을 쓸 수 있습니다. 실수 리터럴이 컴파일 시간에 연산된다면 float64 공간에서 연산됩니다.

```cpp
0.0
-1.557
3.14159265358979
```

### 1.3.3. 문자열 리터럴

- char 형식 : 따옴표로 문자를 둘러싸 char 형식 문자열 리터럴을 표기합니다. 실제로는 정수형 리터럴로 취급됩니다. 유니코드 글자는 해당 글자의 유니코드 포인트 값을 가집니다.
- string 형식 : 쌍따옴표로 문자를 둘러싸 string 형식 문자열 리터럴을 표기합니다. 기본 타입은 u8[]이지만 사용된 표현식에 따라 u8*, u8[N] 타입도 가능합니다. 문자열 데이터는 C 호환성을 위해 길이에 포함되지 않는 널 문자로 종료됩니다. 슬라이스와 포인터 타입 문자열은 데이터 영역에 위치하며 수정할 수 없습니다. 배열 타입의 문자열은 실행시간에 스택 공간에 복사되어 수정이 가능합니다.
- 이스케이프 : 특수문자를 표기하기 위해 두 종류의 문자열 리터럴 모두 다음 이스케이프 처리를 지원합니다. `\0, \t, \r, \n, \', \", \\, \x` 헥스값 이스케이프는 항상 두 자리 16진수가 다음에 와야 합니다.
- 원시 문자열 : 백틱으로 원시 문자열을 표현합니다. 이스케이프 처리가 되지 않고 항상 백틱으로 시작하여 백틱으로 끝납니다.

```cpp
'A'
'가'
'\0'
"Hello, world!\r\n"
"\'\"\t\"\'" // '"  "'
"\x41\x42\x43" // ABC
"\x0F\xff"
`"""`
```

### 1.3.4. 데이터 리터럴

중괄호를 사용해 일렬로 배열된 데이터 구조를 표기합니다. 기본적으로 첫 항목의 타입에 대한 배열이지만 사용된 표현식에 따라 구조체 타입도 가질 수 있습니다. 데이터 리터럴은 원소로 표현식을 가질 수 있고 따라서 컴파일 타임에 값이 확정되지 않습니다.

```cpp
struct Dat {int a; f32 b; bool c;}

{1, 2.0, true} // Dat
{1, 2, 3} // int[3]
{{1, 2, 3}, {4, 5, 6}} // int[2][3]
```

### 1.3.5. 기타 리터럴

`true, false, null` 키워드로 불리언과 포인터 타입 리터럴을 표기합니다. null은 제로 비트패턴입니다.


## 1.4. 변수와 상수 표현식

변수는 프로그램이 사용하는 메모리 공간에 붙인 이름입니다. 상수 표현식은 컴파일 시간에 계산될 수 있는 표현식으로, 리터럴에 대한 연산으로 구성됩니다.

### 1.4.1. 전역변수와 지역변수

전역변수는 모든 범위에서 접근할 수 있는 변수로, 진입점이 아닌 부가 코드의 실행을 막기 위해 상수 표현식으로만 초기화할 수 있습니다. 지역변수는 선언된 스코프 안에서만 유효하며 표현식으로 초기화할 수 있습니다.

```cpp
Point varA;
int varB = 2004;

{
  Point varC = {varB, varB * 2};
  f64 varD;
}
```

### 1.4.2. 변수 선언과 사용

`타입 식별자명`으로 변수를 선언합니다. 변수를 선언하며 할당자를 사용해 동시에 초기화할 수 있습니다. 표현식에서 식별자명을 쓰면 변수를 사용할 수 있습니다.

```cpp
int a;
int b = a;
```

### 1.4.3. 상수 표현식

`4 * 2 - 7 -> 1` 같이 컴파일 시간에 상수식을 접어 단일 리터럴로 축약될 수 있는 표현식을 상수 표현식이라고 합니다.

다음과 같은 연산자가 상수 표현식을 지원합니다.
- `+, -, *, /` : 정수와 실수 연산
- `%, ~, &, |, ^, <<, >>` : 정수 연산
- `<, <=, >, >=` : 정수와 실수 연산
- `==, !=` : 정수, 실수, 불리언 연산
- `&&, ||, !` : 불리언 연산
- `sizeof` : 원시 자료형에 한해 연산

### 1.4.4. 변수 선언 접두어

변수 선언 시 타입 앞에 키워드를 붙여 변수의 속성을 부여할 수 있습니다. 속성은 중복하여 부여할 수도 있습니다. 단, 요구조건이 서로 모순되는 속성은 중복될 수 없습니다.
- `auto` : 타입 대신 사용하며 컴파일러가 초기화 표현식으로 변수의 타입을 추론합니다. 항상 초기화식이 필요합니다.
- `const` : 변수에 대한 직접 재할당을 금지합니다. 다만 **포인터 연산으로 간접적으로 변수를 참조하는 경우 값을 바꾸는 연산을 할 수 있습니다.** 항상 초기화식이 필요합니다.
- `define` : 단일 리터럴에 대해 다른 이름을 붙입니다. 이 속성으로 선언된 변수는 항상 상수 표현식으로 초기화되어야 합니다. 배열 길이에 사용될 수 있습니다.
- `volatile` : 메모리 참조나 하드웨어 동작으로 변수의 메모리가 컴파일러가 모르게 바뀔 수 있음을 선언합니다. 이 속성이 붙은 변수는 컴파일러의 최적화에 제약을 겁니다.
- `extern` : 해당 타입의 변수가 컴파일 타겟 코드에 있음을 선언합니다. C 모듈을 불러올 때, 해당 모듈의 함수와 전역변수를 이 속성을 부여해 선언하면 됩니다. 초기화식을 가질 수 없습니다.
- `export` : 컴파일 결과 코드에 해당 변수의 이름을 노출시킵니다.

```cpp
auto i = 0;
const int j = i + 1;
define int MAX_LEN = 256 * 255 + 255;
volatile auto tag = 0xFFFF;
extern i32(i32, i32) add;
export const f64 PI = 3.141592;
```

## 1.5. 연산자

연산자는 표현식을 받고 특정 연산을 하여 다시 표현식을 만듭니다. femto-C의 모든 연산은 강타입입니다. 표현식의 타입이 암묵적으로 바뀌지 않고 연산자도 암시적 타입 확장을 적용하지 않습니다.

### 1.5.1. 단항연산자

- `+,-` : 단항 부호, 정수->정수, 실수->실수
- `++, --` : 후위 증감, 정수->정수, 전위 증감 연산자는 없음
- `*` : 역참조, 포인터->타입
- `&` : 참조, 타입->포인터
- `!` : 논리 부정, 불리언->불리언
- `~` :  비트 부정, 정수->정수

### 1.5.2. 이항연산자

이항연산자는 기본적으로 같은 타입에 대해서만 연산이 가능합니다. 단, 비트시프트는 좌우 타입이 달라도 됩니다.
- `+, -, *, /` : 산술 덧셈 뺄셈 곱셈 나눗셈, (정수, 정수)->정수, (실수, 실수)->실수
- `%, &, |, ^` :  산술 나머지, 비트 곱 합 XOR, (정수, 정수)->정수
- `<<, >>` : 비트 시프트, (정수, 정수)->정수
- `&&, ||` : 논리 곱 합, (불리언, 불리언)->불리언
- `<, <=, >, >=` : 산술 비교, (정수, 정수)->불리언, (실수, 실수)->불리언
- `==, !=` : 일반 비교, (정수, 정수)->불리언, (실수, 실수)->불리언, (불리언, 불리언)->불리언, (포인터, 포인터)->불리언
- `a.b` : 접근 연산자, 모듈이나 구조체 항목 접근
- `arr[i]` : 인덱싱, (배열, 슬라이스, 포인터)[정수]

### 1.5.3. 삼항연산자

- `cond ? t_expr : f_expr` : 조건 연산자, 불리언 조건식이 참이면 참 표현식 아니면 거짓 표현식을 의미
- `arr[m:n]` : 슬라이싱, (배열, 슬라이스, 포인터)[정수, 정수], 슬라이싱의 시작과 끝 인자는 생략 가능

### 1.5.4. 내장 함수

내장 함수는 사용에 괄호가 필요하며 타입 변환이나 내부 구성요소에 접근할 때 사용합니다.
- `sizeof(T) // type int` : 타입이나 표현식을 받아 바이트 단위 크기를 반환
- `cast<T>(expr)` : 표현식의 타입을 변환
- `len(arr) // type int` : 배열이나 슬라이스를 받아 길이를 반환
- `make(ptr, length)` : 포인터 표현식과 길이를 받아 슬라이스를 생성
- `move(expr)` : 표현식의 값을 반환하되, 원본 표현식의 메모리는 제로필, 인자는 할당식의 좌변에 들어갈 수 있어야 함

### 1.5.5. 연산자 우선순위

C의 연산자 우선순위와 동일합니다.
1. `. [] () ++ --` : 이름 접근, 인덱싱, 슬라이싱, 괄호, 함수 호출, 후위 증감 연산자
2. `+ - ! ~ * &` : 부호, 논리 부정, 비트 부정, 메모리 (단항 연산자)
3. `* / %` : 산술 곱셈, 나눗셈, 나머지
4. `+ -`. 산술 덧셈 뺄셈
5. `<< >>` : 비트 시프트
6. `< <= > >=` : 산술 비교
7. `== !=` : 일반 비교
8. `&`: 비트 곱
9. `^` : 비트 XOR
10. `|` : 비트 합
11. `&&` : 논리 곱
12. `||` : 논리 합
13. `?` : 조건 연산자

## 1.6. 제어문

제어문은 프로그램의 실행 흐름을 제어합니다.

### 1.6.1. 조건문

`if, else` 키워드로 특정 조건일때만 실행되는 문장을 만듭니다. 조건문은 뒤에 단일 문장 혹은 스코프 하나를 받습니다. 조건식에는 불리언 타입만 들어갑니다.

```c
if (i == 0) return 0;
if (j == 1) {
  return 0;
} else if (j == 2) {
  return 1;
} else {
 return 2;
} 
```

### 1.6.2. 반복문

`while, for` 키워드로 특정 조건을 만족시키면 계속 반복되는 문장을 만듭니다. 반복문은 단일 문장을 반복하거나 스코프를 받을 수 있습니다.

```c
while (i != 0) i--;
for (int i = 0; i < len(arr); i++) {
  arr[i] += 256;
}
for (auto i, r : arr) io.printf(“arr[%d] = %s\n”, i, r);
```

- while : `while` 키워드를 사용하여 반복문을 만듭니다. 조건식으로 불리언을 받고 해당 조건이 만족되면 문장을 반복합니다.
- for : `for` 키워드로도 반복문을 만들 수 있습니다. 초기화문, 조건문, 증감문을 받습니다. 초기화문은 반복문 진입 시 처음 한 번만 실행됩니다. 조건문은 불리언이며 조건을 만족하면 문장을 반복합니다. 증감문은 반복문을 빠져나올 때 마지막에 실행됩니다. 각 문은 생략될 수도 있습니다.
- foreach : `for` 키워드를 쓰되 조건문에 배열과 슬라이스를 순회하는 코드를 넣을 수 있습니다. T[] 타입은 (int, T) 타입의 변수들로 순회하게 됩니다. 타입 지정은 auto만 가능하며, 생략 시 값을 이미 존재하는 변수에 할당하게 됩니다.

```c
while (true) {
  break;
  continue;
}
```

반복문 안에서 `break, continue`를 사용하여 반복을 제어할 수 있습니다. break는 반복문 밖으로 바로 나갑니다. continue는 반복문의 시작으로 이동합니다. **break, continue는 반복문만 제어하며, switch와는 무관합니다.**

### 1.6.3. 비교문

정수 조건에 대해, 여러 조건을 동시에 써서 비교할 수 있는 제어문입니다. `switch, case` 키워드를 사용합니다.  조건식으로 정수가 들어가며, 비교식으로 정수 상수 표현식이 들어가야 합니다.

```c
switch (getChar()) {
  case ‘a’:
    io.puts(“it is a\n”);
  case ‘b’:
    io.puts(“it is b\n”);
  case ‘c’:
    io.puts(“it is c\n”);
}
switch (score / 10) {
  case 2:
    io.puts(“pass”);
  case 1:
    io.puts(“you have retry chance\n”);
    fall;
  default:
    io.puts(“fail”);
}
```

해당하는 조건이 없다면 기본 조건식으로 이동합니다. 이 부분은 생략이 가능합니다. 각 조건식에 대해, **해당 부분이 종료되면 다음 조건식으로 이동하지 않고 제어문이 종료**됩니다. `fall` 키워드를 마지막 부분에 명시해야 다음 조건식으로 이동합니다. **fall로 흐름을 넘기는 부분 내부에서는 직접적으로 선언문을 넣을 수 없습니다.**

## 1.7. 함수

함수는 프로그램 실행 흐름을 제어합니다.

### 1.7.1. 함수 선언과 사용

반환 타입과 식별자를 쓰고 괄호 안에 인자 타입과 이름을 넣어 함수를 선언합니다. 함수 본체는 중괄호로 둘러싸 정의합니다. 반환을 하지 않는다면 void 타입을 사용합니다.

```c
void Hello(bool cond) {
  if (!cond) return;
  io.puts(“Hello, world!”);
}
int add(int a, int b) {
  return a + b;
}
int(int, int) func = add;
```

함수 안에서 `return` 키워드로 실행을 종료하고 값을 반환할 수 있습니다. 함수 이름을 그대로 사용하면 함수 포인터 타입으로 쓸 수 있습니다.

### 1.7.2. 함수 호출

함수 이름 혹은 함수 포인터 타입의 식에 인자 표현식을 넣은 괄호를 붙이면 함수를 호출할 수 있습니다. 함수 호출 시 인자는 앞에서부터 평가됨이 보장됩니다.

```c
add(i++, i++ + 1);
myObj.member(“print”);
``` 

### 1.7.3. 가변 인자 함수

`va_arg` 키워드를 함수 선언 앞에 붙여 가변 인자 함수로 만들 수 있습니다. 가변 인자 함수는 기본 인자를 다 채우고 남는 인자를 컴파일러가 자동으로 묶어 전달해 줍니다. 함수 포인터 타입은 가변 인자를 표현할 수 없으므로 사용 시 직접 인자를 묶어야 합니다.

```c
va_arg int sum(void*[]) {...}
va_arg u8[] sprintf(u8[] format, void*[] args, int[] sizes) {...}
```

추가인자는 모두 void* 타입으로 전달됩니다. 함수 호출 시 포인터 타입은 그대로 캐스팅되어 전달되고, 값 타입은 호출자 스택에 복사된 후 메모리 주소가 취해져 전달됩니다. 가변 인자 함수의 마지막 인자는 `void*[]` 혹은 `void*[], int[]`로 끝나야 합니다. `void*[]`는 추가 인자 포인터가 들어오고, `int[]`는 추가 인자 포인터가 가리키는 값의 크기가 들어옵니다.


## 1.8. 구조체

구조체는 여러가지 값을 한 세트로 묶어 쓸 수 있게 해줍니다. 구조체는 값 타입입니다.

### 1.8.1. 구조체의 선언과 사용

`struct` 키워드로 구조체를 선언합니다. 구조체 멤버는 타입과 이름으로 선언하며, 빈 구조체는 존재할 수 없습니다. 구조체는 별도의 키워드 없이 새로운 타입처럼 사용할 수 있습니다. **자동 호이스팅 덕분에 선언부가 사용부보다 나중에 나와도 됩니다.**

```cpp
struct Box {
  Point position;
  int size;
}
struct Point {
    int x;
    int y;
}

Point* v = &{3, 4};
(*v).x;
v.y;
```

구조체 멤버는 점 연산자로 접근합니다. 구조체 포인터라도 똑같이 점 연산자를 사용합니다.

### 1.8.2. 구조체 메서드

함수 선언 시 이름 앞에 구조체명과 점을 붙이면 해당 구조체의 메서드가 됩니다. 다른 구조체의 메서드라면, 점 뒤의 이름이 겹쳐도 됩니다. 메서드의 첫 번째 인자는 구조체 포인터여야 합니다.

```cpp
struct Point {
  int x;
  int y;
}
void Point.move(Point* this) {
  this.x++;
  this.y++;
}

Point v = {3, 4};
v.move();
void(Point*) f = Point.move;
```

메서드를 호출할 때는 구조체 인스턴스 혹은 구조체 포인터 인스턴스에 점 연산자를 사용합니다. 메서드 호출은 괄호가 필요합니다. 함수 포인터 타입으로 메서드 자체를 사용하려면 원본 이름을 써야 합니다.

### 1.8.3. 구조체 멤버 접근 제어

모듈 외부에서 구조체 타입을 사용하려면 대문자로 시작해야 합니다. 대문자로 시작하지 않는 구조체나 멤버는 같은 모듈 내부에서만 사용할 수 있습니다.

```cpp
struct A {
  int Value;
  int value;
  int _value;
}

struct b {
  int Value;
  int value;
  int _value;
}
```

구조체 멤버와 메소드의 접근 제어는 대문자 규칙에 더해 보호 규칙이 추가됩니다. 언더바로 시작하는 멤버나 메서드는 해당 구조체 메서드에서만 접근할 수 있습니다.

### 1.8.4. 구조체 크기 결정

구조체는 기본적으로 C의 메모리 정렬 규칙을 따릅니다. 기본 타입은 해당 타입 크기의 배수인 메모리 주소에 위치해야 합니다.

```cpp
// assume 64bit cpu
struct A {
  i8 _0; // pos 0, size 1
  i32 _1; // pos 4, size 4
  i64 _2; // pos 8, size 8
  i8 _3; // pos 16, size 1
} // size 24
```

단, **컴파일 타겟이 C이면 호스트 C 컴파일러의 크기 결정**에 따릅니다. 이때는 크기 계산이 달라질 수 있습니다.


## 1.9. 열거형

열거형은 정수 상수를 묶어서 한 번에 선언하는 것입니다.

### 1.9.1. 열거형의 선언과 사용

`enum` 키어드로 열거형을 선언합니다. 열거형의 멤버는 같은 열거형 안쪽에서는 서로 독립적인 이름을 가져야 합니다. 열거형은 컴파일 후에는 정수형이 되지만, 코드 상에서는 새로운 타입을 부여한 것과 같습니다. 점 연산자로 열거형 멤버를 사용할 수 있습니다.

```cpp
enum Color {
  Red, // 0
  Green, // 1
  Blue // 2
}
enum Mode {
  Read = 30 * 18, // 540
  Write, // 541
  Error = 0xFFFFFFFF
}
Color a;
Mode b = Mode.Read;
```

열거형 멤버 사용은 정수 상수 표현식으로 취급됩니다.

### 1.9.2. 열거형의 값 할당

열거형의 멤버는 값을 지정하지 않으면 0부터 시작하여, 이전 멤버의 값보다 1 많은 값을 가집니다. 직접 값을 지정하는 경우 초기화식으로 정수 상수 표현식이 올 수 있습니다. 열거형의 컴파일 후 결과물은 크기가 정해져 있지는 않지만, 모든 멤버의 값을 표현할 수 있는 정수형이 됩니다.

```cpp
Color // can be i8, i32, ...
Mode // i64
```


## 1.10. 템플릿

템플릿은 코드를 찍어내는 틀입니다. 다른 자료형에 대해 같은 논리구조의 모듈을 만들 수 있습니다.

### 1.10.1. 템플릿 모듈 선언

`template` 키워드로 템플릿 모듈을 선언하세요. 템플릿 모듈은 자체적으로 컴파일될 수 없고 템플릿 인자를 받아 호출되어야 합니다. 템플릿 선언은 모듈 전체에 효과가 있습니다.

```cpp
// source A
template <T>
T value;

// source B
template <T, U, V>
T(U*, V[]) f;
```

템플릿을 선언하면 템플릿 인자를 가상의 타입처럼 쓸 수 있습니다.

### 1.10.2. 템플릿 모듈 사용

`include` 키워드를 사용할 때, 템플릿 인자 타입을 넣어서 템플릿 모듈을 호출합니다. 매개인자 타입은 피호출자 모듈의 템플릿 인자와 개수가 맞아야 합니다.

```cpp
include<int, T*> "..." name
```

### 1.10.3. 템플릿 코드 구현

템플릿 실체화는 C++처럼 타입을 주입하여 각 코드에 대해 서로 다른 기계어 코드를 생성합니다.

```cpp
// vector.c
template<T>
struct Vector {
  T* Data;
  int Len;
  int Cap;
}
```

```cpp
// main.c
include<Tree> "vector.c" tVec

struct Tree {
  f32 value;
  tVec.Vector children;
}
```

템플릿 모듈 호출은 호출자가 크기를 아는 타입으로만 가능합니다. 최종적으로 크기가 결정되지 않는 구조체가 존재한다면 컴파일되지 않습니다.


## 1.11. 기타 구문

이외에 사용할 수 있는 구문입니다.

### 1.11.1. 지연 삽입문

`defer` 키워드로 지연 표현식 삽입문을 사용합니다. 스코프별로 defer가 스택에 쌓였다가 함수 반환, 루프 탈출을 포함하여 스코프를 나갈 때 자동으로 삽입됩니다. **선언 시점의 값을 기억하지 않고 단순 치환됩니다.**

```cpp
{
  file f = open();
  defer f.close();
}
```

### 1.11.2. 직접 삽입문

`raw_c, raw_ir` 키워드로 타겟 언어를 직접 삽입할 수 있습니다. 타겟 언어가 일치하지 않는 경우에는 아무 코드도 삽입되지 않습니다.

```cpp
raw_c "#include<time.h>"
raw_ir "declare i32 @puts(i8*)"
```


# 2. 표준 컴파일러
2. Standard Compiler

이 항목은 표준 컴파일러를 이용한 femto-C 컴파일 방법에 대한 내용입니다.

## 2.1. 컴파일러 빌드

## 2.2. 컴파일러 입력

## 2.3. 컴파일러 출력

## 2.4. 컴파일러 옵션



# 3. 권장 디자인 패턴
3. Recommended Design Patterns

이 항목은 femto-C를 사용할 때 지키도록 권장되는 코딩 패턴에 대해 다룹니다.

## 3.1. 명명 규칙

### 3.1.1. 기본 규칙

### 3.1.2. 공개 범위별 규칙

### 3.1.3. 메서드 표기 규칙

### 3.1.4. 소유권 표시 규칙


## 3.2. 데이터 전달 패턴

### 3.2.1. 함수 호출

### 3.2.2. 값 할당

### 3.2.3. 안전한 전달


## 3.3. 객체지향 프로그래밍

### 3.3.1. 전역변수 대신 객체

### 3.3.2. 추상화와 캡슐화

### 3.3.3. 생성자와 소멸자

### 3.3.4. 객체 상속

### 3.3.5. 오버라이딩


## 3.4. 자원 관리

### 3.4.1. 지연 삽입문

### 3.4.2. 포인터 규칙

### 3.4.3. 소유권 설정

### 3.4.4. 소유권 없는 빌림

### 3.4.5. 소유권 전달
