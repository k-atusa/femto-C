front: TSLL-C
C의 낡은 문법적 제한을 최신 언어와 비슷하게 개선하고, 더 직관적이고 명확한 코드를 작성하도록 하는 C
편의성을 더한 간결한 문법과 복잡성을 낮춘 컴파일러 제작이 목표

1. 모듈
파일명 기반 모듈 시스템 사용
대문자로 시작하는 변수, 구조체, 함수, 필드만 public 하여 다른 파일에서 사용 가능
#include "filepath" name

2. 리터럴 표기
불리언과 널 (내부적으로 정수와 동일): true (=1), false (=0), null (=0)
10진수, 16진수 리터럴: 123, 0x1a2F 등
실수: 3.1415
char 표기는 단일 따옴표 '' (실제 타입은 u8)
string 표기는 쌍따옴표 "" (실제 타입은 u8[], C문자열처럼 널 문자로 끝나는 데이터 영역에 대한 슬라이스)
escape은 \0 \t \r \n \' \" \\ 지원
배열 리터럴은 {expr, expr, ...}

3. 타입
원시 타입: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, void
타입 접미사: 포인터*, 배열[N], 슬라이스[], 함수(...)
빈 반환값: void
ex. void*, i32[][], f32[4], i64(i64, i64)
타입이나 변수에 대한 sizeof는 바이트 단위 크기를 반환

4. 캐스팅
cast<T>(...)
다음과 같은 캐스팅만 허용됨
원시 타입간 변환(정수-실수 등)은 값이 변경됨
포인터-uint간 변환 허용
포인터-포인터간 변환은 무제한 허용
암시적 형변환은 T* -> void*로만 가능
캐스팅은 변환을 해줄 뿐이지 유효성을 보장하지 않음

5. 변수
T id;
T id = expr;
전역변수의 초기화는 리터럴로만 가능하다
할당자 =는 연산자로 취급하지 않고 할당문에서만 쓰이는 특수문자로 취급

6. 포인터
일반포인터: T*
함수포인터: T(T, T, ...) id
구조체에 대한 포인터라면 . 사용 시 자동으로 (*T).data로 바꿔준다

7. 배열
정수 리터럴의 크기를 가진 정적 배열 (T[N])은 값 타입 (연속된 T들의 메모리 덩어리, 함수 인자 전달 등에서도 덩어리가 통째로 복사됨)
T[4] id; (sizeof(id) == 4*sizeof(T))
&arr[0]으로 첫 항목에 대한 포인터로 변환

8. 슬라이스
내부적으로 첫 항목 포인터 T*과 길이 int를 가진 참조 배열
make(T*, int)로 생성, len()으로 길이를 반환
T[] id; (sizeof(id) == 2*sizeof(void*))

9. 인덱싱과 슬라이싱
포인터, 배열, 슬라이스에 n번째 항목 접근 인덱싱 가능 arr[n]
배열과 슬라이스에는 새 슬라이스를 만드는 슬라이싱 가능 arr[n:m]
arr[n:m]은 make(&arr[n], m-n)과 같으며 프로그램은 유효성을 검사하지 않음

10. 이항연산자
산술: + - * / %
관계: < <= > >= == !=
논리: && ||
비트: & | ^ << >>
구조체/모듈 접근: .

11. 단항연산자
메모리: 역참조 *, 참조 &
산술: -
논리: !
비트: ~

12. 일반 제어문
정수 타입만 조건에 들어가는 bool 값이 될 수 있다. 0만 false고 나머지는 true
if (bool) scope, if (bool) scope else scope, if (bool) scope else if (bool) scope
while (bool) scope

13. 고급 제어문
for (stat; bool; stat) scope
switch (expr) {case literal: ... default: ...} (정수만 받을 수 있다, continue를 넣지 않으면 자동으로 break가 삽입된다)
break; continue;

14. 함수
정의: T id(T parm, T parm...) scope (id는 함수 포인터 타입이다)
반환: return expr;
자동으로 호이스팅되어 인식된다
id(...) (함수 포인터 타입을 호출한다)

15. 가변 인자 함수
#va_arg T id(...) {...}
함수의 마지막 두 인자의 타입은 void**와 정수여야 한다
컴파일러가 함수 호출시 자동으로 남는 인자를 묶어서 전달한다

16. 구조체
struct id {T id; T id; ...}
사용 시 struct를 붙일 필요 없이 자동으로 타입의 일부로 인식된다
자동으로 호이스팅되어 인식된다

17. 구조체 메소드
T T.id(..) {...}
함수명 앞에 구조체 타입명을 붙일 경우 메서드가 된다
메서드의 첫 인자는 구조체 포인터여야 한다
(메서드는 구조체의 메모리를 차지하지 않음, 단지 컴파일러가 처리하는 함수일 뿐)

18. 열거형
enum id {id, id = literal, ...}
열거형은 내부적으론 정수이나 새로운 타입처럼 동작한다
리터럴 지정 없는 열거형은 0부터 시작하며 다음 이름에 1씩 더한 수를 부여한다
리터럴로 해당하는 정수를 직접 지정할 수 있다
열거형은 해당 정수들을 모두 표현할 수 있는 부호 있는 정수 타입 중 가장 작은 타입을 부여받는다

19. 템플릿
코드를 템플릿 모듈로 만드는 템플릿 지시문은 파일당 한 번만 쓸 수 있다
#template<id, ...>
각 id는 데이터 덩어리로 취급되어 형변환이나 함수 포인터로써 실행할 수 없다
템플릿 코드는 데이터 덩어리 크기에 따라 치환된 사본이 생성되어 추가된다
템플릿 모듈을 임포트할 때에는 타입 정보를 추가해야 한다
#include<T, ...> "path" name

20. 컴파일러 지시
주석: //... 과 /* ... */
컴파일러 지시: #order ... 형태
#defer stat (지연 문장은 scope 끝나기 직전에 자동삽입)
컴파일러가 스코프 컴파일 시 스택에 쌓았다가 종료시 역순으로 자동삽입함 (선언 시점의 값을 기억하지 않음, 단순 치환과 동일)
#define T id = literal; (컴파일 타임 상수 선언, 배열 크기 등에 사용 가능, 원시 자료형이여야 하며 항상 초기화되어야 함)
#const T id = expr; (id에 값을 재할당하는 시도 즉 이 변수명에 기반한 lvalue를 막음, 포인터로 이 제약이 풀릴 수 있음)
#volatile T id = expr; (id와 관련된 최적화를 막음)
#raw_c "..." (컴파일 타겟 C에 직접 코드 삽입)
#func_c<id, ...> "..." (id를 사용하여 C 함수를 호출, id는 컴파일 시 이름 매핑을 위해 필요)
#raw_ir "..." (컴파일 타겟 IR에 직접 코드 삽입)
#func_ir<id, ...> "..." (id를 사용하여 IR 함수를 호출, id는 컴파일 시 이름 매핑을 위해 필요)

==========
연산자 우선순위
필드 접근.
단항+- 논리! 비트~ 포인터*&
산술*/%
산술+-
비트<< >>
논리< <= > >=
논리 == !=
비트&
비트^
비트|
논리&&
논리||

==========
계획 : 
1. main 소스 파일에서 시작하여 모든 소스를 읽어 AST로 만듦. 타입 검증은 하지 않음. 이 단계에서 순환 의존성을 감지함.
- 1단계를 마치면 {소스 파일 경로, AST}의 벡터가 의존성 순서대로 생길 것이다. 이 순서는 추후 코드 생성 단계에서 참조된다.
2. 타입 매핑을 시작함. 먼저 모든 일반 소스와 템플릿 소스의 정적 크기 자료형을 계산함. 열거형이나 필드가 원시 자료형만으로 이루어진 구조체는 크기가 확정됨.
- 더이상 정적 크기 계산이 불가능할 때까지 반복한다.
3. 반복적 타입 완성. {고유번호, 타입 트리}로 모듈 타입 테이블 인스턴스를 구성함. 큐에는 구조체 완성 요청과 템플릿 인스턴스화 요청이 들어감. 각 요청은 어느 소스의 어느 AST가 해당 요청에 해당하는지 정보를 가짐.
- 모든 일반 소스를 순회하며 구조체 완성 요청과 템플릿 인스턴스화 요청을 넣는다. 모듈 인스턴스도 추가한다.
- 각 요청 중 하위 필드의 크기가 모두 확정되면 크기를 구하고 모듈 인스턴스 정보를 업데이트한다.
- 템플릿 매개변수 크기가 확정되면 해당 템플릿을 인스턴스화 하여 모듈 인스턴스와 구조체, 템플릿 요청을 추가한다. 이때 크기가 겹치는 요청은 추가하지 않는다.
- 더 이상 변화가 일어나지 않을 때까지 반복한다.
