front: femto-C
- C의 낡은 문법적 제한을 최신 언어와 비슷하게 개선
- 더 직관적이고 명확한 코드를 작성하도록 하는 문법
- C 기능 중 버그 유발 가능성이 높은 것을 제거하고 타 언어의 유용한 기능을 일부 가져옴
- 편의성을 더한 간결한 문법과 복잡성을 낮춘 컴파일러 제작

1. 모듈
파일명 기반 모듈 시스템 사용
대문자[A-Z]로 시작하는 변수, 함수, 구조체, 열거형, 멤버만 public 하여 다른 모듈에서 사용 가능
#include "filepath" name
호이스팅이 되기 때문에 함수, 구조체, 열거형 등은 선언과 함께 정의가 있어야 한다 (빈 구조체 등 불가)

2. 리터럴 표기
불리언 true, false
널 null (=0)
10진수, 2진수, 8진수, 16진수 리터럴: 123, 0b1011, 0o755, 0x1a2F 등
실수: 3.1415
char 표기는 단일 따옴표 '' (아스키문자/유니코드 1자)
string 표기는 쌍따옴표 "" (실제 타입은 u8[], C문자열처럼 널 문자로 끝나는 데이터 영역에 대한 슬라이스)
escape은 \0 \t \r \n \' \" \\ \x 지원 (\xNN 처럼 항상 두 자리로 사용)
`` 백틱을 사용해 줄바꿈을 포함하는 raw string 사용 (escape를 인식하지 않고 항상 백틱으로 시작하고 끝남)
중괄호 리터럴은 연속한 데이터 구조를 나타내며 배열이나 구조체 리터럴이다 {expr, expr, ...}

3. 타입
원시 타입: int, i8, i16, i32, i64, uint, u8, u16, u32, u64, f32, f64, bool, void
타입 접미사: 포인터*, 배열[N], 슬라이스[], 함수(...)
배열과 슬라이스 접미사는 C와 동일하게 연속한 경우 역순으로 인식됨
함수 빈 반환값 표시: void
ex. void*, i32[][], f32[4], i64(i64, i64)
타입이나 변수에 대한 sizeof는 바이트 단위 크기를 반환
#typedef T E 타입 E에 대한 별칭 T를 생성

4. 캐스팅
cast<T>(...)
다음과 같은 캐스팅만 허용됨
원시 타입간 변환(정수-실수 등)은 값이 변경됨
포인터-uint간 변환 허용
포인터-포인터간 변환은 무제한 허용
암시적 형변환을 허용하지 않음
캐스팅은 변환을 해줄 뿐이지 유효성을 보장하지 않음

5. 변수
T id;
T id = expr;
auto id = expr; 타입 추론은 지역 변수에서만 가능하며 초기화식이 필요하다
#const, #volatile 변수 선언 시 붙일 수 있다 (const는 명시적 재할당만 금지하며 포인터로 깨질 수 있음)
전역변수의 초기화는 리터럴로만 가능하다
할당자는 연산자로 취급하지 않고 할당문에서만 쓰이는 특수문자로 취급
다음과 같은 할당자만 지원 = += -= *= /= %=

6. 포인터
일반포인터: T*
함수포인터: T(T, T, ...) id
구조체에 대한 포인터라면 . 사용 시 자동으로 (*T).data로 바꿔준다

7. 배열과 슬라이스
배열 T[N]은 정수 리터럴의 크기를 가진 값 타입 (연속된 T들의 메모리 덩어리, 함수 인자 전달 등에서도 덩어리가 통째로 복사됨)
&arr[0]으로 첫 항목에 대한 포인터로 변환
T[4] id; (sizeof(id) == 4*sizeof(T))
슬라이스 T[]은 내부적으로 첫 항목 포인터 T*과 길이 int로 구성
make(T*, int)로 생성, len()으로 길이를 반환
T[] id; (sizeof(id) == 2*sizeof(void*))

8. 인덱싱과 슬라이싱
포인터, 배열, 슬라이스에 n번째 항목 접근 인덱싱 가능 arr[n]
배열과 슬라이스에는 새 슬라이스를 만드는 슬라이싱 가능 arr[n:m]
arr[n:m]은 make(&arr[n], m-n)과 같으며 프로그램은 유효성을 검사하지 않음

9. 연산자
삼항:
    슬라이싱: a[n:m]
    조건: bool ? a : b
이항:
    산술: + - * / %
    관계: < <= > >= == !=
    논리: && ||
    비트: & | ^ << >>
    구조체/모듈 접근: .
단항:
    메모리: 역참조 *, 참조 &
    산술: -
    논리: !
    비트: ~

10. 제어문
조건식에는 bool 타입만 들어간다
if (bool) scope, if (bool) scope else scope, if (bool) scope else if (bool) scope
while (bool) scope
for (var_decl; bool; assign_or_expr) scope
switch (expr) {case literal: ... default: ...} (정수만 받을 수 있다, continue를 넣지 않으면 자동으로 break가 삽입된다)
break; 반복문의 끝으로 점프한다
continue; 반복문의 시작으로 점프한다
fall; switch 안에서 다음 case로 이동한다

11. 함수
정의: T id(T parm, T parm...) scope (id는 함수 포인터 타입이다)
반환: return expr;
자동으로 호이스팅되어 인식된다
id(...) (함수 포인터 타입을 호출한다)
#va_arg T id(...) {...}로 가변 인자 함수를 정의한다
가변 인자 함수의 마지막 인자의 타입은 void*[]여야 한다
컴파일러가 함수 호출시 자동으로 남는 인자를 묶어서 전달한다
함수 호출 시 포인터는 void*로, 값 타입은 복사된 후 주소값이 취해져 void*로 전달된다

12. 구조체
struct id {T id; T id; ...}
사용 시 struct를 붙일 필요 없이 자동으로 타입의 일부로 인식된다
자동으로 호이스팅되어 인식된다
T T.id(..) {...}로 구조체 메서드를 정의한다
함수명 앞에 구조체 타입명을 붙일 경우 메서드가 된다
메서드의 첫 인자는 구조체 포인터여야 한다
(메서드는 구조체의 메모리를 차지하지 않음, 단지 컴파일러가 처리하는 함수일 뿐)
_로 시작하는 멤버와 메서드는 private 하여 해당 구조체 메서드 안에서만 사용 가능하다

13. 열거형
enum id {id, id = literal, ...}
열거형은 내부적으론 정수이나 새로운 타입처럼 동작한다
리터럴 지정 없는 열거형은 0부터 시작하며 다음 이름에 1씩 더한 수를 부여한다
리터럴로 해당하는 정수를 직접 지정할 수 있다
열거형은 해당 정수들을 모두 표현할 수 있는 부호 있는 정수 타입 중 가장 작은 타입을 부여받는다

14. 지연 삽입문
#defer expr; 지연 문장은 scope 끝나기 직전에 역순으로 자동삽입
컴파일러가 스코프 컴파일 시 스택에 쌓았다가 종료시 역순으로 자동삽입함 (선언 시점의 값을 기억하지 않음, 단순 치환과 동일)

15. 주석과 직접 코드 삽입
주석: //... 과 /* ... */
#raw_c "..." 컴파일 타겟 C에 직접 코드 삽입
#raw_ir "..." 컴파일 타겟 IR에 직접 코드 삽입

16. 기타 컴파일러 지시
컴파일러 지시: #order ... 형태
#define T id = literal; 컴파일 타임 상수 선언, 배열 크기 등에 사용 가능, 원시 자료형이여야 하며 항상 초기화되어야 함
#extern T id; 컴파일 타겟에 타입 T인 전역변수 id가 있음을 선언, 함수일 경우 T가 함수 포인터 타입
#export ... 해당 전역변수나 함수를 컴파일 결과 C 헤더파일에 노출

17. 템플릿
#template T로 템플릿 타입과 템플릿 모듈 선언
#include<T, E, ...> "..." name 으로 템플릿 모듈 참조
템플릿 인스턴스화 과정에서 타입이 치환됨

==========
연산자 우선순위 (C와 동일)
필드 접근. 인덱싱[] 함수호출()
단항+- 논리! 비트~ 포인터*&
산술*/%
산술+-
비트<< >>
논리< <= > >=
논리 == !=
비트&
비트^
비트|
논리&&
논리||
