컴파일메세지
1 최소단위 반복성
2 중간단위
3 모듈 단위
4 전체 메세지
5 경고나 오류

위치구조체
AST1에서의 위치를 기록

A1스코프노드
모든 변수는 명시적 변수 선언 노드로 들어감

template 타입은 크기를 아는 절대 참조 타입

A1Ext
이때부터는 include의 uname 기반으로 검색을 시작함.
include/struct/typedef
include : 일반 참조는 바로 인스턴스화.
템플릿 참조는 크기를 알면 표준화한 타입으로 인스턴스화.
struct : 반복 크기 계산
typedef : struct 범위 안은 모두 치환
template -> typedef로 치환

A1TypeType {
    NONE, -> NONE
    AUTO, -> NONE
    PRIMITIVE, -> 원시 타입
    POINTER, -> 포인터 (...)
    ARRAY, -> 배열 (...)
    SLICE, -> 슬라이스 (...)
    FUNCTION, -> 함수 (...)
    NAME, -> 같은 모듈 안에서 선언된 구조체/열거형/템플릿명
    FOREIGN, -> 다른 모듈에 선언된 구조체/열거형
    TEMPLATE -> 절대참조형 구조체/열거형
};


함수 {
  배열 복사..
  상태 변수 선언
  반환 변수 선언

  {구문..}

  최종 라벨A
  배열 복사..
  반환 변수 반환
}

스코프 {
  구문..

  라벨A
  defer..

  if (상태 > 0) {상태--; jump to 상위 스코프 라벨A}
}

loop {
  구문..

  라벨A // continue라면 여기까지 와서 (상태 == 0), break라면 (상태 == 1)
  defer..
  if (상태 == 0) {step 구문; continue;}
  else if (상태 == 1) {상태--; break;}
  else {상태--; jump to 상위 스코프 라벨A}
}

break -> 해당 반복문 나가는 크기로 상태 변수 설정, jump to 현재 스코프 라벨A
continue -> 해당 반복문 나가는 크기로 상태 변수 설정, jump to 현재 스코프 라벨A
return -> 반환 변수 설정, 모든 반복문 나가는 크기로 상태 변수 설정, jump to 현재 스코프 라벨A

ast3
배열 : 코드 상으론 값 타입이나 실재 사용시엔 포인터로 사용
일정 크기 이상 메모리 작업은 자동 경고
구현순서 : ast2 선언 정렬순으로 넣기 -> 함수 본문 채우기

prestat 필요 경우:
expr:
  literal_data 사용
  삼항 연산자 안쪽에서 prestat 쓰는 경우
  문자열을 슬라이스 포장
  단축 평가 내부 prestat 사용
  가변인자함수 포장
  함수 호출이 있는 인자 포장
  r-value 메서드 호출
  배열 반환 시 값 복사
stat:
  배열 대입 시 값 복사
decl:
  배열 인자 사용 시 값 복사
  배열 반환 시 값 복사

c 차이점:
  모듈, 대문자 가시성
  명시적 타입, 강타입
  값 타입 배열, 슬라이스 뷰
  구조체, 함수 호이스팅
  defer
  switch 자동 break
  할당은 문장