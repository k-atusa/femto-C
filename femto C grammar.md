# femto C 문법

femto C는 종합 시스템 프로그래밍 프로젝트인 femto-X에서 사용하기 위해 k-atusa가 개발한 현대적 저수준 언어입니다.
C의 유연한 저수준 제어에 rust의 메모리 안전성을 단순하고 통일성 있게 도입하고자 했습니다.

#### 설계자 사설

문법을 보면 사실 C보단 rust를 많이 닮았습니다.
최대한 C 스타일을 지향하려고 했는데 "현대적"으로 만들다 보니 자연스럽게 kotlin이나 rust의 디자인과 비슷한 결과가 나와 버렸습니다.

메모리를 직접 조작하는 저수준 언어라고 하면 C, C++, rust가 유명합니다.
하지만 세 언어 모두 장단점이 매우 명확합니다. 그리고 셋의 장점을 결합하려는 시도는 굉장히 어려웠습니다.
왜 rust가 유명세에 비해 정작 쓰이는 곳은 한정적인지, 왜 모던 C++는 이렇게 복잡하게 진화하는지, 그리고 왜 C가 portable "assembly"인지.
그들이 그렇게 생긴 데에는 다 그럴만한 이유가 있었습니다.

femto라는 이름에 맞게 최대한 단순하게 만들려고 했는데 문법 사양 자체만 보면 클래식 C보단 꽤 복잡해졌습니다.
하지만 코드를 실제로 짜는 복잡도와 메모리 관리를 생각하면, 더 간단해졌을 것이라고 생각합니다.



## 0. 키워드

총 키워드 개수는 32개로, 표준 C에 32개, 모던 C++의 98개, rust의 50개에 비하면 작은 편입니다.

### 타입 (10개)

```u, i, f, int, bool, true, false, void, box, mut```

### 변수와 메모리 (5개)

```var, const, new, malloc, free```

### 제어 (10개)

```if, else, switch, case, default, while, for, break, continue, defer```

### 함수와 구조체 (3개)

```func, return, struct```

### 예외처리와 모듈 (4개)

```try, catch, raise, include```



## 1. 타입 시스템

원시값 타입은 정수, 실수, 불리언과 같이 작은 크기를 가지는 타입을 말합니다.

### 정수

```u8, u16, u32, u64, i8, i16, i32, i64, uint, int```

말 그대로 정수입니다. uint와 int는 플랫폼 종속적인 크기를 갖습니다.
10진수로 표현하거나 0x로 시작하는 16진수 표현법이 있습니다.

### 실수

```f32, f64```

부동소수점 실수입니다.

### 불리언

```bool```

true 혹은 false의 진리값입니다.

### 원시 포인터

```일반 포인터 *T, 원형 포인터 *void, 함수 포인터 (func (...): T)```

C의 일반적인 포인터입니다. femto C에서는 원시 포인터도 많이 사용하도록 설계되었습니다.

### 참조형

```소유권 포인터 box T, 불변 참조 &T, 가변 참조 &mut T```

참조형은 사실 하드웨어 레벨에서는 똑같은 *T입니다.
box는 소유한다는 의미입니다.
개발자가 의도하는 부분을 원시 포인터에 추가한 것이라고 생각하면 됩니다.
포인터의 동작이 의도를 벗어나는지 컴파일러가 검증해 줄 것입니다.

### 타입 전치사

```스택 배열 [N]T, 힙 배열 []T, nullable 표지 ?```

동일한 타입 여러 개가 연속된 메모리 공간상에 있음을 []를 붙여 나타낼 수 있습니다.
[N]은 크기를 컴파일 타임에 알 수 있지만 []는 모른다는 의미입니다.
앞에 ?가 붙으면 void일 수 있습니다.
[10]i32, ?box []f64, ?&mut [][]u8처럼 사용합니다.

### 타입 캐스팅

C와 동일하게 (T) id로 타입을 변환합니다.



## 2. 소유권 시스템

소유권 시스템이 왜 필요할까요?
C의 포인터는 단순한 주소값입니다. 스택에 있는지 힙에 있는지, 지금 유효한지 아니면 이미 free 된 상태인지,
언제 어떤 함수에서 free를 해야 정확히 딱 한 번만 free되는지 아무런 정보가 없습니다.
소유권 시스템은 포인터에 제약을 부여하여 개발자가 설정한 범위를 벗어나는 동작을 하는 것을 컴파일러가 잡아낼 수 있도록 합니다.
개발자가 직접 코드를 짜며 포인터를 추적하는 것보다 간편하고, 메모리 버그를 원천적으로 예방할 수 있습니다.

### box T의 의미

box T는 "타입이 T인 어떤 힙 인스턴스에 대한 소유권 있는 포인터"입니다.
소유권은 곧 책임입니다. box T는 생성될 때 힙 메모리를 할당받고, 소멸될 때 메모리를 반환할 "책임"을 집니다.
소유권은 유일하기 때문에 두 번 반환될 위험이 없습니다.
또한 항상 유효한 (non-null) 인스턴스를 가리키는 포인터이기도 합니다.
box T가 아닌 다른 곳에서 이 포인터를 해제할 수 없기 때문입니다.

### 생명주기

scope (범위)는 중괄호 {}로 표기합니다.
box T는 scope 안에서 살아 있습니다.
선언될 때부터 scope가 종료될 때까지 유효하며, scope 종료 시 자동으로 소멸자가 호출됩니다.
동시에 여러 변수가 소유권을 가질 수 없기 때문에 대입이나 함수 인자 전달 시 소유권은 "이동" 합니다.

### 참조 규칙

&T와 &mut T는 항상 유효한 메모리 T에 대한 참조입니다. 스택/힙 상관 없고 소유권도 없습니다.
따라서 참조가 살아 있는 한, 참조의 원본 변수도 "살아" 있어야 합니다.
한 변수를 여러 스레드가 동시에 쓰면 데이터가 깨질 수 있습니다.
이를 방지하기 위해 동시에 "여러 개의 &T" 혹은 "하나의 &mut T"만 존재할 수 있습니다.

#### 설계자 사설

원래 단순성을 위해 box T만 도입하려고 했는데, 그럴 수 없었습니다.
box T, &T, &mut T는 소유권 개념이 들어오면 같이 들어오는 한 세트이기 때문입니다.
C 개발자에겐 낯설겠지만, "유효한 메모리"를 위해 포인터 사용에 제약을 부여했고 컴파일러가 검증한다고 생각하면 됩니다.



## 3. 원시 포인터

하드웨어는 unsafe 하기 때문에 safe한 코드만으로 모든 일을 처리할 수는 없습니다.
femto C는 원시 포인터를 활용하는 것도 중요하게 생각합니다.
malloc과 free로 직접 *T를 다룰 수 있습니다.

### 원시 포인터와 관리 포인터 사이 변환규칙

기본적으로 ```*T, box T, &T, &mut T``` 모두 포인터인데, 각 포인터의 의미를 생각하면서 상호 변환할 수 있습니다.

```box T, &T, &mut T -> *T``` : 소유권은 여전히 T에 있고, 잠시 그 주소값을 빌려가는 것입니다.
T가 메모리를 소유하기 때문에 free(*T)로 메모리를 해제해 버리면 오류가 발생합니다.

```*T -> &T, &mut T``` : 원시 포인터가 "소유"한 메모리를 잠시 빌리는 것입니다.
개발자가 컴파일러에게 이 메모리 *T는 유효하고 참조자가 살아 있는 한 계속 살아 있다고 보증하는 것입니다.
참조자가 수명주기가 끝나지 않았는데 free를 해 버리면 오류가 발생합니다.

```*T -> box T``` : 명시적인 소유권 이동입니다.
개발자가 컴파일러에게 box T가 유효한 메모리 주소를 관리한다고 보증하는 것입니다.
메모리의 소유권이 넘어갔기 때문에 free를 하거나 box T의 수명 이후에 *T를 사용하면 오류가 발생합니다.

### unsafe 함수

함수명 뒤에 ?를 붙여 선언합니다. (id?)
진짜 "위험"한 원시 포인터 동작은 unsafe 함수 내부로 격리되어야 합니다.
```malloc, free, *T 산술연산, *T 역참조, *T에서 box T, &T, &mut T로의 캐스팅```은 unsafe 함수 내부에서만 가능합니다.



## 4. 변수 선언

var id: type; var id: type = expr; const id: type = expr;
처럼 선언하며 상수, box T, &T, &mut T는 선언과 함께 초기화되어야 합니다.
상수에는 다시 할당을 할 수 없으며, box T에 새 값을 할당하면 기존 값은 자동으로 delete 됩니다.
최상위 문에 선언되면 전역변수가 됩니다.

## 5. 배열과 동적 메모리

### 배열

배열은 이제 더이상 포인터가 아닙니다. 연속된 스택 변수들의 집합이며 크기가 타입에 포함됩니다.
즉 [10]int와 [20]int는 다른 타입입니다.
var id: [constexpr]T; var id: [M][N]T = {...};처럼 선언합니다.
물론 원시 포인터로 변환하면 모두 *T이며 기존 C 스타일과 연동하여 쓸 수 있습니다.

### 동적 메모리

new는 힙 메모리를 확보한 후 항상 box 타입만을 반환합니다.
var id: box T = new T; var id: box T = new T(...);처럼 선언합니다.

### 동적 배열

box []T 타입은 내부적으로 {data *T, len int}로 구성되며 인덱싱이 유효한지 런타임에 검증합니다.
var id: box []T = new [expr]T;처럼 선언합니다.



## 6. 인덱싱과 슬라이싱

### 인덱싱

연속된 T들의 메모리 공간 중 한 T에 직접 접근합니다.
id[expr]처럼 사용합니다.

### 슬라이싱

슬라이스는 어떤 연속된 T들의 메모리에 대한 부분 참조입니다. borrow checker가 적용됩니다.
슬라이스도 내부적으로 {data *T, len int}로 구성되며 인덱싱이 유효한지 검증합니다.
슬라이스는 소유권이 없기 때문에 스택의 정적 배열 [N]T, 힙의 동적 배열 box []T, 그리고 다른 슬라이스에 대해 모두 만들 수 있습니다.
var s: &[]T = &id[n:m]; var s: &mut []T = &mut id[n:m];처럼 사용합니다.

## 7. 연산자

익숙한 C의 연산자들입니다. 동일한 우선 순위를 가집니다. 단, 단항 연산자 일부와 할당 연산자는 빠졌습니다.

### 산술

```+ - * / %```

### 관계

```< <= > >= == !=```

### 논리

```&& || !```

### 비트

```& | ~ ^ << >>```

### 메모리

```역참조 * (*T, &T, &mut T에 적용), 참조 & (T, box T, &T, &mut T에 적용), 참조 &mut (box T, &mut T에 적용)```



## 8. 제어문

C의 제어문과 아주 흡사합니다.

### 조건문

```if (bool) {...}
if (bool) {...} else {...}
if (bool) {...} else if (bool) {...}

switch(integer) {
    case constexpr: ...
    case a, b: ...
    default: ....
}```

### 반복문

```while (bool) {...}
for (st; bool; st) {...}```

### 흐름 제어

break, continue로 switch와 반복문을 제어합니다.
swich는 기본 break가 되어 있으며 continue로 계속 아래로 내려갑니다.
defer st;는 스코프가 끝나면 역순으로 실행되는 지연 평가입니다.

## 9. 함수

id가 언더바(_)로 시작하는 함수만 private하며, unsafe 지시자(?)는 private 여부에 영향 없습니다.

```func id(...) {...}
func id(a: T, b: T): T {...}
return expr;
```

## 10. 구조체

id가 언더바(_)로 시작하는 구조체 혹은 필드만 private합니다.
필드와 메서드 접근은 .을 사용하며, 구조체 포인터는 자동 역참조됩니다.
생성자와 소멸자, 역참조 복사는 특수 이름 __new, __delete, __copy 메서드를 쓸 수 있습니다.

```struct T { id: type; id: type; }

func (self: box T) __new(...): box T {...}
func (self: box T) __delete(...) {...}
func (self: &T) __copy(...): box T {...}

func (self: *T) id(...) {...}
func (self: &T) id(...) {...}
func (self: &mut T) id(...) {...}```



## 11. 예외 처리

일반적인 예외는 오류코드 반환으로 처리하는 것이 좋습니다.
try catch문은 스택 되감기를 하기에 느립니다.
심각한 오류만 try, catch, raise (box T만 던지기 가능)로 처리합니다.
try 블록 안에서 명시적으로 raise되는 모든 예외의 타입을 catch에서 받아야 합니다.
예외 객체 err.e {code: int; msg: box []u8}를 제공할 예정입니다.
```try {
    raise id;
    raise new T(...);
} catch (var e: box T) {
    ...
}```

## 12. 모듈

파일명 기반 모듈입니다.
include name;처럼 사용합니다.
표준 라이브러리 std, C 표준 라이브러리 c.xxx

## 13. 컴파일러 지시

주석은 ```//, /* */```으로 달며, #order로 컴파일러에게 직접 명령을 내릴 수 있습니다.

```#raw_asm {...}```
```#raw_llvm {...}```
```#raw_c {...}```
```#define {...}```
```#enum {...}```

## 14. 예제 코드
