# femto-C v0.5 문법 표준안
femto-C v0.5 Grammar Standard

# 1. 문법 명세
1. Grammar Specification

이 항목은 femto-C의 문법과 동작을 정의합니다. 기본적으로 C 스타일의 문법을 사용하며, 이 문서에 명시되지 않은 사항은 정의되지 않은 행동이거나 표준 컴파일러의 구현 정의를 따릅니다.

## 1.1. 프로그램 구조

복잡한 헤더 파일과 전역 변수명 겹침으로부터 벗어나세요. femto-C는 모듈 기반으로 간략하지만 강력한 프로젝트 구성이 가능합니다. 

### 1.1.1. 모듈

femto-C는 파일 경로 기반 모듈 시스템을 사용합니다. 소스 파일 하나가 모듈 하나입니다. 모듈은 다른 모듈을 불러와 사용할 수도 있지만, 순환 참조는 허용되지 않습니다. 모듈 파일 경로로 절대경로와 상대경로 모두 사용 가능합니다. 상대경로를 쓰는 경우 호출자 소스의 위치를 기준으로 상대 경로를 사용합니다.

```c
include "path_to_module" name
name.Object v;
```

include 키워드로 다른 모듈을 불러오고 접근 이름을 지정합니다. 점 연산자로 다른 모듈 항목에 접근합니다. 전역변수와 함수, 구조체와 열거형 타입, 타입 별칭 선언문이 다른 모듈에서 사용될 수 있습니다.

### 1.1.2. 표현식, 문장, 선언문, 주석

프로그램은 모듈로 구성되고, 모듈은 선언문으로 구성됩니다. 표현식, 문장, 선언문, 주석은 C와 동일한 개념입니다.

```c
1 + 2
myVar.Method(a)
str[:]
```

표현식은 어떠한 값을 연산하여 결과가 되는 것으로, 값을 가집니다. 할당문의 좌변에 오는 표현식은 상수가 아니며 (non-const), 메모리 주소를 가진 (l-value) 표현식이여야 합니다.

```c
print("Hello");
myVar.count++;
1 + a;
```

문장은 프로그램이 동작하도록 명령을 내립니다. 문장의 종류로는 어떤 이름이나 타입을 선언하는 선언문, 값을 좌변에 대입하는 할당문, 값을 계산하거나 함수를 호출하는 표현식문이 있습니다.

```c
a = b;
a += b; // a = a + b;
a -= b; // a = a - b;
a *= b; // a = a * b;
a /= b; // a = a / b;
a %= b; // a = a % b;
arr[i++] += 1; // auto v = &arr[i++]; *v = *v + 1;
```

단순 할당자는 우변의 값을 좌변에 할당합니다. 복합 할당자는 좌변과 우변을 연산한 값(이때 좌변은 한 번만 평가됩니다)을 할당합니다. 할당문은 다음 할당자를 지원하며 `=, +=, -=, *=, /=, %=`, 이는 연산자로 취급하지 않습니다. 즉 표현식 안에 할당문이 올 수 없습니다. 이는 고질적인 오타 문제(if (i = 0) ... 등)를 예방합니다.

```c
int i = 0;
void* p = null;
struct Point {int x; int y;}
```

선언문은 이름이나 타입을 선언합니다. 선언문으로 `모듈 접근자, 전역변수, 지역변수, 함수, 메소드, 타입 별칭`의 이름과 `구조체, 열거형, 템플릿` 타입을 선언할 수 있습니다.

```c
// single line comment
/*
  multi
  line
  comment
*/
```

주석은 C와 동일하게 한 줄 주석과 여러 줄 주석을 지원합니다.

### 1.1.3. 이름 명명 조건

식별자 이름으로 영문, 언더바, 유니코드 문자를 사용할 수 있습니다. 식별자명은 숫자로 시작해서는 안 됩니다. 유니코드 문자는 일부 컴파일러에서는 호환성 문제를 일으킬 수도 있습니다.

```c
basicVar
PubliVar
_privateVar
_012
한글_이름
```

### 1.1.4. 스코프와 이름공간

중괄호로 스코프를 나타냅니다. 스코프는 이름이 유효한 범위를 의미합니다. 변수명과 타입 별칭은 로컬 스코프에서도 선언할 수 있습니다. 이외의 타입과 이름은 전역 공간에서만 선언할 수 있습니다. 이름은 선언하기 전에는 사용할 수 없습니다. 또한 전역 이름은 어디에서나 쓸 수 있지만, 로컬 이름은 스코프 안에서만 유효합니다.

```c
int PublicGlobal = 0;
int basicGlobal = 1;
{
  int local0 = 2;
  {
    int local1 = 3;
  }
}
```

모듈 접근자, 전역변수, 함수, 구조체명 등은 모두 전역 이름공간을 쓰므로 서로 겹칠 수 없습니다. 지역변수는 전역 이름공간이나 상위 스코프에서 선언된 이름을 쓸 수 있지만, 이 경우 해당 이름을 가리게 됩니다. 즉 중복 선언된 이름은 해당 이름이 유효한 스코프에서는 사전에 선언된 이름에 접근할 수 없습니다.

### 1.1.5. 가시성 규칙

femto-C는 간단한 대문자 가시성 규칙을 따릅니다. 이 규칙은 같은 femto-C 코드 사이에서의 가시성을 제어합니다.

```c
int PublicVar;
int basicVar;
struct Point {int A; int b; int _c;}
```

기본적으로 모듈 안에서 선언된 이름은 해당 모듈 안에서만 접근할 수 있습니다. 이름 첫 글자를 대문자[A-Z]로 한 경우에만 다른 모듈에서도 접근할 수 있는 공개 이름이 됩니다. 구조체 멤버와 메서드에 한해서, 언더바로 시작하는 이름은 내부명입니다. 이 이름은 해당 구조체의 메서드에서만 접근할 수 있습니다.

### 1.1.6. 전역 초기화와 프로그램 진입점

전역변수는 리터럴로만 초기화할 수 있습니다. 이는 메인 함수 진입 전 따로 코드가 먼저 실행되는 것을 막습니다. 메인 함수는 정수를 반환하며, 실행 인자를 받을 수도 있습니다. 프로그램을 실행파일로 빌드하기 위해서는 메인 함수 진입점이 필요합니다.

```c
int main() { }
int main(u8[][]) { }
```


## 1.2. 타입 시스템

### 1.2.1. 정수형 원시 타입

### 1.2.2. 실수형 원시 타입

### 1.2.3. 기타 원시 타입

### 1.2.4. 배열

### 1.2.5. 슬라이스

### 1.2.6. 포인터

### 1.2.7. 함수 포인터

### 1.2.8. 타입 별칭

### 1.2.9. 타입 변환


## 1.3. 리터럴 표기

### 1.3.1. 정수 리터럴

### 1.3.2. 실수 리터럴

### 1.3.3. 문자열 리터럴

### 1.3.4. 이스케이프 표기

### 1.3.5. 기타 리터럴


## 1.4. 변수와 상수 표현식

### 1.4.1. 전역변수와 지역변수

### 1.4.2. 변수 선언과 사용

### 1.4.3. 상수 표현식

### 1.4.4. 변수 선언 접두어


## 1.5. 연산자

### 1.5.1. 단항연산자

### 1.5.2. 이항연산자

### 1.5.3. 삼항연산자

### 1.5.4. 내장 함수

### 1.5.5. 연산자 우선순위


## 1.6. 제어문

### 1.6.1. 조건문

### 1.6.2. 반복문

### 1.6.3. 비교문


## 1.7. 함수

### 1.7.1. 함수 선언과 사용

### 1.7.2. 함수 호출

### 1.7.3. 가변 인자 함수


## 1.8. 열거형

### 1.8.1. 열거형의 선언과 사용

### 1.8.2. 열거형의 값 할당


## 1.9. 구조체

### 1.9.1. 구조체의 선언과 사용

### 1.9.2. 구조체 메서드

### 1.9.3. 구조체 멤버 접근 제어


## 1.10. 템플릿

### 1.10.1. 템플릿 모듈 선언

### 1.10.2. 템플릿 모듈 사용

### 1.10.3. 템플릿 코드 구현


## 1.11. 기타 구문

### 1.11.1. 지연 삽입문

### 1.11.2. 직접 삽입문



# 2. C와의 차이점 및 주의사항
2. Differences with C and Cautions

이 항목은 기존 C 사용자들이 혼란을 느끼거나, 잘 알지 못하면 성능이나 안전성을 해칠 수 있는 사항에 대한 내용입니다.

## 2.1. 모듈과 가시성

## 2.2. 배열의 동작

## 2.3. 할당문 차이

## 2.4. 암시적 변환 없는 강타입

## 2.5. 제어 키워드 역할 차이

## 2.6. 지연 삽입문 실행 시점

## 2.7. 인덱싱과 슬라이싱 안전성



# 3. 권장 디자인 패턴
3. Recommended Design Patterns

이 항목은 femto-C를 사용할 때 지키도록 권장되는 코딩 패턴에 대해 다룹니다.

## 3.1. 명명 규칙

### 3.1.1. 기본 규칙

### 3.1.2. 공개 범위별 규칙

### 3.1.3. 메서드 표기 규칙

### 3.1.4. 소유권 표시 규칙


## 3.2. 데이터 전달 패턴

### 3.2.1. 함수 호출

### 3.2.2. 값 할당

### 3.2.3. 안전한 전달


## 3.3. 객체지향 프로그래밍

### 3.3.1. 전역변수 대신 객체

### 3.3.2. 추상화와 캡슐화

### 3.3.3. 생성자와 소멸자

### 3.3.4. 객체 상속

### 3.3.5. 오버라이딩


## 3.4. 자원 관리

### 3.4.1. 지연 삽입문

### 3.4.2. 포인터 규칙

### 3.4.3. 소유권 설정

### 3.4.4. 소유권 없는 빌림

### 3.4.5. 소유권 전달



# 4. 표준 컴파일러
4. Standard Compiler

이 항목은 표준 컴파일러를 이용한 femto-C 컴파일 방법에 대한 설명입니다.

## 4.1. 컴파일러 빌드

## 4.2. 컴파일러 입력

## 4.3. 컴파일러 출력

## 4.4. 컴파일러 옵션
