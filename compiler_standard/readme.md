# femto-C v0.5 문법 표준안
femto-C v0.5 Grammar Standard

# 1. 문법 명세
1. Grammar Specification

이 항목은 femto-C의 문법과 동작을 정의합니다. 기본적으로 C 스타일의 문법을 사용하며, 이 문서에 명시되지 않은 사항은 정의되지 않은 행동이거나 표준 컴파일러의 구현 정의를 따릅니다.

## 1.1. 프로그램 구조

복잡한 헤더 파일과 전역 변수명 겹침으로부터 벗어나세요. femto-C는 모듈 기반으로 이름과 접근을 제어합니다.

### 1.1.1. 모듈

femto-C는 파일 경로 기반 모듈 시스템을 사용합니다. 소스 파일 하나가 모듈 하나입니다. 모듈은 다른 모듈을 불러와 사용할 수도 있지만, 순환 참조는 허용되지 않습니다. 모듈 파일 경로로 절대경로와 상대경로 모두 사용 가능합니다. 상대경로를 쓰는 경우 호출자 소스의 위치를 기준으로 상대 경로를 사용합니다.

```c
include "path_to_module" name
name.Object v;
```

include 키워드로 다른 모듈을 불러오고 접근 이름을 지정합니다. 점 연산자로 다른 모듈 항목에 접근합니다. 전역변수와 함수, 구조체와 열거형 타입, 타입 별칭 선언문이 다른 모듈에서 사용될 수 있습니다.

### 1.1.2. 표현식, 문장, 선언문, 주석

프로그램은 모듈로 구성되고, 모듈은 선언문으로 구성됩니다. 표현식, 문장, 선언문, 주석은 C와 동일하게 사용됩니다.

```c
1 + 2
myVar.Method(a)
str[:]
```

표현식은 값을 가지며 어떠한 연산의 결과가 됩니다. 할당문의 좌변에 오는 표현식은 상수가 아니며 (non-const), 메모리 주소를 가진 (l-value) 표현식이여야 합니다.

```c
print("Hello");
myVar.count++;
1 + a;
```

문장은 프로그램이 동작하도록 명령을 내립니다. 문장의 종류로는 어떤 이름이나 타입을 선언하는 선언문, 값을 좌변에 대입하는 할당문, 값을 계산하거나 함수를 호출하는 표현식문이 있습니다.

```c
a = b;
a += b; // a = a + b;
a -= b; // a = a - b;
a *= b; // a = a * b;
a /= b; // a = a / b;
a %= b; // a = a % b;
arr[i++] += 1; // auto v = &arr[i++]; *v = *v + 1;
```

단순 할당자는 우변의 값을 좌변에 할당합니다. 복합 할당자는 좌변과 우변을 연산한 값(이때 좌변은 한 번만 평가됩니다)을 할당합니다. 할당문은 다음 할당자를 지원하며 `=, +=, -=, *=, /=, %=`, **이는 연산자로 취급하지 않습니다.** 즉 표현식 안에 할당문이 올 수 없습니다. 이는 고질적인 오타 문제(if (i = 0) ... 등)를 예방합니다.

```c
int i = 0;
void* p = null;
struct Point {int x; int y;}
```

선언문은 이름이나 타입을 선언합니다. 선언문으로 `모듈 접근자, 전역변수, 지역변수, 함수, 메소드, 타입 별칭`의 이름과 `구조체, 열거형, 템플릿` 타입을 선언할 수 있습니다.

```c
// single line comment
/*
  multi
  line
  comment
*/
```

주석은 C와 동일하게 한 줄 주석과 여러 줄 주석을 지원합니다.

### 1.1.3. 이름 명명 조건

식별자 이름으로 영문, 언더바, 유니코드 문자를 사용할 수 있습니다. 식별자명은 숫자로 시작해서는 안 됩니다. 유니코드 문자는 일부 컴파일러에서는 호환성 문제를 일으킬 수도 있습니다.

```c
basicVar
PubliVar
_privateVar
_012
한글_이름
```

다음 키워드와 기본 타입명은 식별자명으로 사용할 수 없습니다.

```c
include, template, struct, enum, defer, templte,
va_arg, const, volatile, extern, export,
if, else, while, for, switch, case, default,
break, continue, fall, return,
cast, sizeof, len, make, move,
true, false, null, auto,
int, i8, i16, i32, i64,
uint, u8, u16, u32, u64,
f32, f64, bool, void,
raw_c, raw_ir
```

### 1.1.4. 스코프와 이름공간

중괄호로 스코프를 나타냅니다. 스코프는 이름이 유효한 범위를 의미합니다. 변수명과 타입 별칭은 로컬 스코프에서도 선언할 수 있습니다. 이외의 타입과 이름은 전역 공간에서만 선언할 수 있습니다. 이름은 선언하기 전에는 사용할 수 없습니다. 또한 전역 이름은 어디에서나 쓸 수 있지만, 로컬 이름은 스코프 안에서만 유효합니다.

```c
int PublicGlobal = 0;
int basicGlobal = 1;
{
  int local0 = 2;
  {
    int local1 = 3;
  }
}
```

모듈 접근자, 전역변수, 함수, 구조체명 등은 모두 전역 이름공간을 쓰므로 서로 겹칠 수 없습니다. 지역변수는 전역 이름공간이나 상위 스코프에서 선언된 이름을 쓸 수 있지만, 이 경우 해당 이름을 가리게 됩니다. 즉 중복 선언된 이름은 해당 이름이 유효한 스코프에서는 사전에 선언된 이름에 접근할 수 없습니다.

### 1.1.5. 가시성 규칙

femto-C는 간단한 대문자 가시성 규칙을 따릅니다. 이 규칙은 같은 femto-C 코드 사이에서의 가시성을 제어합니다.

```c
int PublicVar;
int basicVar;
struct Point {int A; int b; int _c;}
```

기본적으로 모듈 안에서 선언된 이름은 해당 모듈 안에서만 접근할 수 있습니다. 이름 첫 글자를 대문자[A-Z]로 한 경우에만 다른 모듈에서도 접근할 수 있는 공개 이름이 됩니다. 구조체 멤버와 메서드에 한해서, 언더바로 시작하는 이름은 내부명입니다. 이 이름은 해당 구조체의 메서드에서만 접근할 수 있습니다.

### 1.1.6. 전역 초기화와 프로그램 진입점

전역변수는 리터럴로만 초기화할 수 있습니다. 이는 메인 함수 진입 전 따로 코드가 먼저 실행되는 것을 막습니다. 메인 함수는 정수를 반환하며, 실행 인자를 받을 수도 있습니다. 프로그램을 실행파일로 빌드하기 위해서는 메인 함수 진입점이 필요합니다.

```c
int main() { }
int main(u8[][]) { }
```


## 1.2. 타입 시스템

femto-C는 타입 중심 설계를 따릅니다. 이는 C의 표현식 중심 설계보다 정형적이지만 프로그래머가 변수의 타입을 추적하기 쉽습니다. 타입은 타입 뿌리에 타입 접미사를 붙여 의미를 표현합니다. 타입 선언에 공백을 사용하는 것은 허용되지만 괄호는 허용되지 않습니다.

### 1.2.1. 정수형 원시 타입

정수형 타입은 고정된 크기를 가지거나 아키텍쳐 결정 크기를 가집니다. 부호있는 정수형은 2의 보수 형태로 저장되며, 제로 비트패턴은 0임이 보장됩니다.

`int, i8, i16, i32, i64, uint, u8, u16, u32, u64`

### 1.2.2. 실수형 원시 타입

실수형 타입은 고정된 크기를 가집니다. IEEE 754 부동소수점 형태로 저장되며, 제로 비트패턴은 0임이 보장됩니다.

`f32, f64`

### 1.2.3. 기타 원시 타입

불리언 타입은 1 바이트 크기를 가집니다. 제로 비트패턴은 거짓, 나머지는 참으로 해석됩니다. 보이드 타입은 크기를 가지지 않으며 직접적으로 사용할 수 없습니다. 함수가 값을 반환하지 않음을 나타내거나, 임의 포인터(void*)를 표기하는데에 쓰입니다.

`bool, void`

### 1.2.4. 배열

타입 끝에 양의 정수 값이 들어있는 대괄호를 붙여 배열을 선언합니다. 배열은 연속한 데이터 덩어리입니다. **C와 달리 값 타입으로 취급되며 함수 호출이나 할당 시 값 자체가 복사됩니다.** C와 동일하게 다차원 배열을 선언할 수 있습니다. T[a][b]는 ((T가 b번 연속한 것)이 a번 연속한 것)을 의미합니다. define 변수도 배열 길이로 사용할 수 있습니다.

```c
int[4]
f32[16][32]

define n = 4;
i32[n] var;
```

### 1.2.5. 슬라이스

타입 끝에 빈 대괄호를 붙여 슬라이스를 선언합니다. 슬라이스는 데이터 포인터와 길이가 같이 들어있는 확장 포인터입니다. 일반 포인터의 2배 크기를 가집니다. 다차원으로 선언하거나 배열과 혼합하여 사용할 수 있습니다.

```c
int[]
f32[][]
u8[8][] // actual meaning ( u8[] )[8]
struct Slice {void* data; int length;} // inner structure
```

### 1.2.6. 포인터

타입 끝에 애스터리스크를 붙여 포인터를 선언합니다. 포인터는 값이 메모리 주소이며 아키텍쳐 결정 크기를 가지는 정수형으로 생각할 수 있습니다. 임의의 자료형을 가리키기 위해서는 void*를 사용합니다.

```c
int*
f32**
void*
```

### 1.2.7. 함수 포인터

타입 끝에 괄호를 붙여 함수 포인터 타입을 선언합니다. 함수 포인터는 femto-C와 C의 타입 표기법 중 가장 차이가 큰 곳입니다. 함수 포인터 구조는 간단하게 직관적으로 생각하면 좋습니다.

```c
void()
int(int, int)
bool(i32, i32)(f64(f64, f64), i64)
```

위의 타입 세 가지는 다음 의미를 가집니다.
- 인자를 받지 않고 반환도 하지 않는 함수
- 인자로 정수형 2개를 받고 정수형을 반환하는 함수
- 인자로 ((인자로 64비트 실수형 2개를 받고 64비트 실수형을 반환하는 함수)와 64비트 정수형)를 받고 (인자로 32비트 정수형 2개를 받고 불리언을 반환하는 함수)를 반환하는 함수

### 1.2.8. 타입 별칭

typedef 키워드로 타입에 대한 다른 이름을 만들 수 있습니다. 타입 별칭은 변수와 같은 유효 범위(스코프 규칙, 대문자 규칙)를 가집니다.

```c
typedef str u8[]
typedef myFunc i32(i32, i32)

str[]
bool(myFunc, i32, i32)
```

### 1.2.9. 타입 변환

femto-C에는 암시적 형 변환이 없습니다. 명시적 캐스팅이 없다면 표현식의 타입은 바뀌지 않습니다. cast 키워드로 표현식의 타입을 변환할 수 있습니다. 변환 결과 타입은 유효한 타입이여야 합니다.

```c
cast<int>(expr)
cast<void*>(expr)
```

타입 변환은 다음과 같은 경우에만 허용됩니다.
- void를 제외한 원시 타입간 변환. 값 자체가 바뀌는 것이라 비트 패턴이 바뀔 수 있습니다.
- 정수형과 포인터형간 변환. 정수형이 음수라면 강제로 양수 비트 패턴으로 해석됩니다.
- 포인터형간의 변환. 포인터 대상에 상관 없이 무제한적으로 단순 변환됩니다.


## 1.3. 리터럴 표기

리터럴은 값 자체를 나타내며 사용되는 표현식에 따라 다른 타입을 가질 수도 있습니다.

### 1.3.1. 정수 리터럴

10진수, 2진수, 8진수, 16진수 정수형을 쓸 수 있습니다. 정수 리터럴이 컴파일 시간에 연산된다면 int64 공간에서 연산됩니다.

```c
0
42
-2147483649
0b1011
-0o755
0x8a91
0xFfff
```

### 1.3.2. 실수 리터럴

10진수 실수형을 쓸 수 있습니다. 실수 리터럴이 컴파일 시간에 연산된다면 float64 공간에서 연산됩니다.

```c
0.0
-1.557
3.14159265358979
```

### 1.3.3. 문자열 리터럴

- char 형식 : 따옴표로 문자를 둘러싸 char 형식 문자열 리터럴을 표기합니다. 실제로는 정수형 리터럴로 취급됩니다. 유니코드 글자는 해당 글자의 유니코드 포인트 값을 가집니다.
- string 형식 : 쌍따옴표로 문자를 둘러싸 string 형식 문자열 리터럴을 표기합니다. 기본 타입은 u8[]이지만 사용된 표현식에 따라 u8*, u8[N] 타입도 가능합니다. 문자열 데이터는 C 호환성을 위해 길이에 포함되지 않는 널 문자로 종료됩니다. 슬라이스와 포인터 타입 문자열은 데이터 영역에 위치하며 수정할 수 없습니다. 배열 타입의 문자열은 실행시간에 스택 공간에 복사되어 수정이 가능합니다.
- 이스케이프 : 특수문자를 표기하기 위해 두 종류의 문자열 리터럴 모두 다음 이스케이프 처리를 지원합니다. `\0, \t, \r, \n, \', \", \\, \x` 헥스값 이스케이프는 항상 두 자리 16진수가 다음에 와야 합니다.

```c
'A'
'가'
'\0'
"Hello, world!\r\n"
"\'\"\t\"\'" // '"  "'
"\x41\x42\x43" // ABC
"\x0F\xff"
```

### 1.3.4. 데이터 리터럴

중괄호를 사용해 일렬로 배열된 데이터 구조를 표기합니다. 기본적으로 첫 항목의 타입에 대한 배열이지만 사용된 표현식에 따라 구조체 타입도 가질 수 있습니다. 데이터 리터럴은 원소로 표현식을 가질 수 있고 따라서 컴파일 타임에 값이 확정되지 않습니다.

```c
struct Dat {int a; f32 b; bool c;}

{1, 2.0, true} // Dat
{1, 2, 3} // int[3]
{{1, 2, 3}, {4, 5, 6}} // int[2][3]
```

### 1.3.5. 기타 리터럴

`true, false, null` 키워드로 불리언과 포인터 타입 리터럴을 표기합니다. null은 제로 비트패턴입니다.


## 1.4. 변수와 상수 표현식

변수는 프로그램이 사용하는 메모리 공간에 붙인 이름입니다. 상수 표현식은 컴파일 시간에 계산될 수 있는 표현식으로, 리터럴에 대한 연산으로 구성됩니다.

### 1.4.1. 전역변수와 지역변수

전역변수는 모든 범위에서 접근할 수 있는 변수로, 진입점이 아닌 부가 코드의 실행을 막기 위해 단일 리터럴로만 초기화할 수 있습니다. 지역변수는 선언된 스코프 안에서만 유효하며 표현식으로 초기화할 수 있습니다.

```c
Point varA;
int varB = 2004;

{
  Point varC = {varB, varB * 2};
  f64 varD;
}
```

### 1.4.2. 변수 선언과 사용

`타입 식별자명`으로 변수를 선언합니다. 변수를 선언하며 할당자를 사용해 동시에 초기화할 수 있습니다. 표현식에서 식별자명을 쓰면 변수를 사용할 수 있습니다.

```c
int a;
int b = a;
```

### 1.4.3. 상수 표현식

`4 * 2 - 7 -> 1` 같이 컴파일 시간에 상수식을 접어 단일 리터럴로 축약될 수 있는 표현식을 상수 표현식이라고 합니다.

다음과 같은 연산자가 상수 표현식을 지원합니다.
- `+, -, *, /` : 정수와 실수 연산
- `%, &, |, ^, <<, >>` : 정수 연산
- `<, <=, >, >=` : 정수와 실수 연산
- `==, !=` : 정수, 실수, 불리언 연산
- `&&, ||, !` : 불리언 연산
- `sizeof` : 원시 자료형에 한해 연산

### 1.4.4. 변수 선언 접두어

변수 선언 시 타입 앞에 키워드를 붙여 변수의 속성을 부여할 수 있습니다. 속성은 중복하여 부여할 수도 있습니다. 단, 요구조건이 서로 모순되는 속성은 중복될 수 없습니다.
- `auto` : 타입 대신 사용하며 컴파일러가 초기화 표현식으로 변수의 타입을 추론합니다. 항상 초기화식이 필요합니다.
- `const` : 변수에 대한 직접 재할당을 금지합니다. 다만 포인터 연산으로 간접적으로 변수를 참조하는 경우 값을 바꾸는 연산을 할 수 있습니다. 항상 초기화식이 필요합니다.
- `define` : 단일 리터럴에 대해 다른 이름을 붙입니다. 이 속성으로 선언된 변수는 항상 상수 표현식으로 초기화되어야 합니다. 배열 길이에 사용될 수 있습니다.
- `volatile` : 메모리 참조나 하드웨어 동작으로 변수의 메모리가 컴파일러가 모르게 바뀔 수 있음을 선언합니다. 이 속성이 붙은 변수는 컴파일러의 최적화에 제약을 겁니다.
- `extern` : 해당 타입의 변수가 컴파일 타겟 코드에 있음을 선언합니다. C 모듈을 불러올 때, 해당 모듈의 함수와 전역변수를 이 속성을 부여해 선언하면 됩니다. 초기화식을 가질 수 없습니다.
- `export` : 컴파일 결과 코드에 해당 변수의 이름을 노출시킵니다.

```c
auto i = 0;
const int j = i + 1;
define int MAX_LEN = 256 * 255 + 255;
volatile auto tag = 0xFFFF;
extern i32(i32, i32) add;
export const f64 PI = 3.141592;
```

## 1.5. 연산자

### 1.5.1. 단항연산자

### 1.5.2. 이항연산자

### 1.5.3. 삼항연산자

### 1.5.4. 내장 함수

### 1.5.5. 연산자 우선순위


## 1.6. 제어문

### 1.6.1. 조건문

### 1.6.2. 반복문

### 1.6.3. 비교문


## 1.7. 함수

### 1.7.1. 함수 선언과 사용

### 1.7.2. 함수 호출

### 1.7.3. 가변 인자 함수


## 1.8. 열거형

### 1.8.1. 열거형의 선언과 사용

### 1.8.2. 열거형의 값 할당


## 1.9. 구조체

### 1.9.1. 구조체의 선언과 사용

### 1.9.2. 구조체 메서드

### 1.9.3. 구조체 멤버 접근 제어


## 1.10. 템플릿

### 1.10.1. 템플릿 모듈 선언

### 1.10.2. 템플릿 모듈 사용

### 1.10.3. 템플릿 코드 구현


## 1.11. 기타 구문

### 1.11.1. 지연 삽입문

### 1.11.2. 직접 삽입문



# 2. C와의 차이점 및 주의사항
2. Differences with C and Cautions

이 항목은 기존 C 프로그래머들이 혼란을 느끼거나, 잘 알지 못하면 성능이나 안전성을 해칠 수 있는 사항에 대한 내용입니다.

## 2.1. 모듈과 가시성

## 2.2. 배열의 동작

## 2.3. 할당문 차이

## 2.4. 암시적 변환 없는 강타입

## 2.5. 제어 키워드 역할 차이

## 2.6. 지연 삽입문 실행 시점

## 2.7. 인덱싱과 슬라이싱 안전성



# 3. 권장 디자인 패턴
3. Recommended Design Patterns

이 항목은 femto-C를 사용할 때 지키도록 권장되는 코딩 패턴에 대해 다룹니다.

## 3.1. 명명 규칙

### 3.1.1. 기본 규칙

### 3.1.2. 공개 범위별 규칙

### 3.1.3. 메서드 표기 규칙

### 3.1.4. 소유권 표시 규칙


## 3.2. 데이터 전달 패턴

### 3.2.1. 함수 호출

### 3.2.2. 값 할당

### 3.2.3. 안전한 전달


## 3.3. 객체지향 프로그래밍

### 3.3.1. 전역변수 대신 객체

### 3.3.2. 추상화와 캡슐화

### 3.3.3. 생성자와 소멸자

### 3.3.4. 객체 상속

### 3.3.5. 오버라이딩


## 3.4. 자원 관리

### 3.4.1. 지연 삽입문

### 3.4.2. 포인터 규칙

### 3.4.3. 소유권 설정

### 3.4.4. 소유권 없는 빌림

### 3.4.5. 소유권 전달



# 4. 표준 컴파일러
4. Standard Compiler

이 항목은 표준 컴파일러를 이용한 femto-C 컴파일 방법에 대한 설명입니다.

## 4.1. 컴파일러 빌드

## 4.2. 컴파일러 입력

## 4.3. 컴파일러 출력

## 4.4. 컴파일러 옵션
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3NzM5Nzc3MiwtMTUyOTk1MTQ4Niw1Mz
QwNTE1OTYsMTYzODUyMTAyMywxODUxNjEyMzk5XX0=
-->